\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{color}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{relsize}
\usepackage{dsfont}
\usepackage{graphicx}
\usepackage[margin=2cm]{geometry}
\usepackage{tikz}
\usetikzlibrary{calc}

\newcommand{\K}{\ensuremath\mathbb{K}}
\newcommand{\N}{\ensuremath\mathbb{N}}
\newcommand{\Z}{\ensuremath\mathbb{Z}}
\newcommand{\Q}{\ensureFmath\mathbb{Q}}
\newcommand{\R}{\ensuremath\mathbb{R}}
\newcommand{\U}{\ensuremath\mathbb{U}}
\newcommand{\C}{\ensuremath\mathbb{C}}
\newcommand{\E}{\ensuremath\mathbb{E}}
\newcommand{\V}{\ensuremath\mathbb{V}}
\renewcommand{\P}{\ensuremath\mathbb{P}}

\renewcommand{\(}{\left(}
\renewcommand{\)}{\right)}

\newcommand{\la}{\leftarrow}
\newcommand{\xla}{\xleftarrow}
\newcommand{\ra}{\rightarrow}
\newcommand{\xra}{\xrightarrow}

\renewcommand\labelitemi{---}

%\setlength\parindent{0pt}

\newtheorem*{definition}{Définition}
\newtheorem*{theorem}{Théorème}
\newtheorem*{algo}{Algorithme}
\renewcommand*{\proofname}{Preuve}

\title{Union-Find Blossom algorithm implementation}

\author{Thibaut Pérami, Théophile Wallez}

\begin{document}

\maketitle

\section{Data structure}

Our main structure is an alternating tree which look like this :

\begin{center}
\begin{tikzpicture}
  \tikzstyle{every node}=[draw,shape=circle];
  \node (r) at (0,0) {$r$};
  \node (1) at (2,2) {$1$};
  \node (2) at (2,0) {$2$};
  \node (3) at (2,-2) {$3$};
  \node (1b) at (4, 2) {$1b$};
  \node (2b) at (4, 0) {$2b$};
  \node (3b) at (4,-2) {$3b$};
  \foreach \n in {1,2,3}{
    \draw (r) -- (\n);
  }
  \draw[ultra thick] (1) -- (1b);
  \draw[ultra thick] (2) -- (2b);
  \draw[ultra thick] (3) -- (3b);

  \foreach \n in {1b,2b,3b}{
    \foreach \x in {-0.5,0,0.5}{
      \node (tmp) at ([shift=({2,\x})]\n) {$$};
    \draw (\n) -- (tmp);
    }
  }
\end{tikzpicture}
\end{center}

The tree is included in the graph. The bold edge are the the edge in the
matching. The nodes that are at an odd distance from the root are called
\emph{before} nodes and those at even distance are called \emph{after} nodes

We also have an union-find structure to represent nodes in the contracted graph: for a
given node in the original graph, its class in the union-find is the
corresponding node in the contracted graph. In practice there is no rank
constraint optimization in the union-find because, we need the force which is
the representant of each class (see section 3)

Thus we maintain at the same time two trees, the tree in the contracted graph and the
tree in the original graph. Only the tree in the contracted graph is an
alternating tree (before node are contracted in after node and thus the will
have edge not in matching going out of them).
In practice, only the tree in original graph is
stored and the tree in contracted graph is deduced with the union find. The tree
is simply stored by remembering for each node which is its parent node. It is
thus impossible to move down in the tree. If you want to go up in the parent
tree you just need to take the representant of the parent node.

\section{Main algorithm}

While exploring we maintain a list of after node to be explored. The main
algorithm consist of taking a node in this list and exploring it until either an
augmenting path is found or the list is empty ans thus there exists no
augmenting path starting from $r$.


During the exploration of a after node we look at all its neighbors, there are
some possibilities:
\begin{itemize}
\item Both nodes are in the same contracted node : ignore
\item The neighbor has already been visited as a before node : we do nothing
\item The neighbor has already been visited as an after node : we have found a
  cycle, see section 3.
\item The neighbor has never been visited and is matched : we add this new node
  and its match to the tree and we add the matching node to the todo list.
\item The neighbor has never been visited and is not matched : we have found an
  augmenting path, we can trivially have an augmenting path in the contracted
  graph by going up in the tree but we want one in the original graph. (see in
  section 4 to see how we do it)
\end{itemize}



\section{Contracting}

Recherche ancêtre commun

union-find

reexploration des sommet before.

\section{Augmenting}

Exemple sur cycle simple + dessin

Cas de profondeur 2 et genéralisation + dessin.

\section{Initialization}

Théophile






\end{document}
